import pandas as pd
import random
import demes
import re
import argparse
import os

def parse_args():
    parser = argparse.ArgumentParser(description='Create a tbs file for msmodified from a demes graph and confidence intervals')
    parser.add_argument('--demes_yaml', type=str, help='Path to the demes yaml file', required=True)
    parser.add_argument('--confint', type=str, help='Path to the confidence intervals csv file', required=True)
    parser.add_argument('--path_to_msmodified', type=str, help='Path to the msmodified executable', required=True)
    parser.add_argument('--migration', type=str, help='Migration direction: ab, ba, abba, baab, none', required=True)
    parser.add_argument('--odir', type=str, help='Output directory', required=True)
    parser.add_argument('--nreps', type=int, help='Number of replicates', default=5000)
    parser.add_argument('--L', type=int, help='Length of the sequence', default=100_000)
    parser.add_argument('--mu', type=float, help='Mutation rate', default=6e-9)
    parser.add_argument('--rec', type=float, help='Recombination rate', default=1.9e-8)
    parser.add_argument('--mtime', type=int, help='Maximum migration time in generations', default=10000)
    return parser.parse_args()

def get_graph_from_yaml(demes_yaml):
    """
    Load the demes graph from a yaml file
    """
    graph = demes.load(demes_yaml)
    return graph

def remove_ancestral_populations(graph):
    """
    The demes yaml generated by GADMA2 has 2 ancestral populations of one epoch each.

    This function removes the ancestral populations (graph.demes[0] and graph.demes[1]) from the demes graph
    and assign their epochs to the first daughter population (graph.demes[2]).
    """
    def get_epoch_dict(epoch):
        """
        Get a dictionary version of the epoch from the demes graph - needed by graph.Builder.add_deme(epoch=[dict])
        """
        return {
            "start_size": epoch.start_size,
            "end_size": epoch.end_size,
            "end_time": epoch.end_time,
            "size_function": epoch.size_function
        }
    # build a new graph
    graph2 = demes.Builder()
    
    # demes[2] will be the new demes[0] inheriting the epochs from the ancestral populations plus its own epochs
    deme0_epochs = []
    for epoch in graph.demes[0].epochs:
        deme0_epochs.append(get_epoch_dict(epoch))
    for epoch in graph.demes[1].epochs:
        deme0_epochs.append(get_epoch_dict(epoch))
    for epoch in graph.demes[2].epochs:
        deme0_epochs.append(get_epoch_dict(epoch))
    # add the deme to the new graph
    graph2.add_deme(
        name=graph.demes[2].name,
        epochs=deme0_epochs,
        ancestors=None,
        proportions=None,
        start_time=None,
        description=graph.demes[2].description
    )
    # while the demes[3] will be the new demes[1] inheriting its own epochs from the original graph
    deme1_epochs = []
    for epoch in graph.demes[3].epochs:
        deme1_epochs.append(get_epoch_dict(epoch))
    # add the deme to the new graph
    graph2.add_deme(
        name=graph.demes[3].name,
        epochs=deme1_epochs,
        ancestors=[graph.demes[2].name],
        proportions=graph.demes[3].proportions,
        start_time=graph.demes[3].start_time,
        description=graph.demes[3].description
    )
    return graph2.resolve()

def get_populations(graph):
    """
    Get the populations names from the demes graph
    """
    pop1 = graph.demes[0].name
    pop2 = graph.demes[1].name
    return pop1, pop2

def get_ms_command(graph, N0, samples, mu, L, rec, migration, mtime):
    """
    Get the ms command from the demes graph using demes.to_ms
    """
    theta = 4 * N0 * mu * L 
    rho = rec * 4 * N0 * (L - 1)
    mscommand = demes.to_ms(graph, N0=N0, samples=samples)
    mscommand = f'-t {theta} -r {rho} {L} {mscommand}'
    # add migration to the ms command (not the graph) based on the migration direction
    if migration == "ba":
        # t_split = graph.demes[1].start_time
        # mig_time = random.uniform(0, t_split / 10)
        mig_time = random.uniform(0, mtime)
        mig_time = mig_time / N0 / 4
        # mig_prop = random.uniform(0.01, 0.3)
        mig_prop = 0.95
        mscommand += f' -es {mig_time} 1 {mig_prop} -ej {mig_time} 3 2'
    elif migration == "ab":
        # t_split = graph.demes[1].start_time
        # mig_time = random.uniform(0, t_split / 10)
        mig_time = random.uniform(0, mtime)
        mig_time = mig_time / N0 / 4
        # mig_prop = random.uniform(0.01, 0.3)
        mig_prop = 0.95
        mscommand += f' -es {mig_time} 2 {mig_prop} -ej {mig_time} 3 1'
    elif migration == "abba":
        # t_split = graph.demes[1].start_time
        # mt1 = random.uniform(0, t_split / 10)
        # mt2 = random.uniform(0, t_split / 10)
        mt1 = random.uniform(0, mtime / 10)
        mt2 = random.uniform(0, mtime / 10)
        mig_time1 = min(mt1, mt2) / N0 / 4
        mig_time2 = max(mt1, mt2) / N0 / 4
        # mig_prop1 = random.uniform(0.01, 0.3)
        mig_prop1 = 0.95
        # mig_prop2 = random.uniform(0.01, 0.3)
        mig_prop2 = 0.95
        mscommand += f' -es {mig_time1} 2 {mig_prop1} -ej {mig_time1} 3 1 -es {mig_time2} 1 {mig_prop2} -ej {mig_time2} 4 2'
    elif migration == "baab":
        # t_split = graph.demes[1].start_time
        # mt1 = random.uniform(0, t_split / 10)
        # mt2 = random.uniform(0, t_split / 10)
        mt1 = random.uniform(0, mtime / 10)
        mt2 = random.uniform(0, mtime / 10)
        mig_time1 = min(mt1, mt2) / N0 / 4
        mig_time2 = max(mt1, mt2) / N0 / 4
        # mig_prop1 = random.uniform(0.01, 0.3)
        mig_prop1 = 0.95
        # mig_prop2 = random.uniform(0.01, 0.3)
        mig_prop2 = 0.95
        mscommand += f' -es {mig_time1} 1 {mig_prop1} -ej {mig_time1} 3 2 -es {mig_time2} 2 {mig_prop2} -ej {mig_time2} 4 1'
    elif migration == "none":
        mscommand += f' -es 0.0001 1 1.0 -ej 0.0001 3 2'
    else:
        raise ValueError("Migration direction not contemplated in the get_ms_command script")
    return mscommand

def get_ms_string(mscommand, path_to_msmodified, size1, size2, nreps, L):
    """
    Get the ms string with tbs instead of parameters to be used in a bash script
    """
    # get absolute path to msmodified
    path_to_msmodified = os.path.abspath(path_to_msmodified)
    # split the mscommand into the different flags
    pattern = r'(?=\s-[a-zA-Z])'
    commands = [f.strip() for f in re.split(pattern, mscommand)]
    # first part of the ms string
    ms_string = f'{path_to_msmodified} {size1 + size2} {nreps}'
    # add the flags with tbs instead of parameters to the ms string
    for command in commands:
        flag = command.split(' ')[0]
        if flag not in ['-t', '-r', '-I', '-n', '-g', '-en', '-eg', '-ej', '-es']:
            raise ValueError(f'Command from demography not contemplated in the script: {flag}')
        if flag == '-t':
            ms_string += f' {flag} tbs'
        elif flag == '-r':
            ms_string += f' {flag} tbs {L}'
        elif flag == '-I':
            ms_string += f' {flag} {command.split(" ")[1]} {size1} {size2}'
        elif flag in ['-n', '-g']:
            ms_string += f' {flag} {command.split(" ")[1]} tbs'
        elif flag in ['-en', '-eg', '-es']:
            ms_string += f' {flag} tbs {command.split(" ")[2]} tbs'
        elif flag in ['-ej']:
            ms_string += f' {flag} tbs {command.split(" ")[2]} {command.split(" ")[3]}'
    # add the last part of the ms string
    ms_string += f' < mig.tbs | tee mig.msOut\n'
    return ms_string

def get_tbs_list(mscommand):
    pattern = r'(?=\s-[a-zA-Z])'
    commands = [f.strip() for f in re.split(pattern, mscommand)]
    tbs_list = []
    for command in commands:
        flag = command.split(' ')[0]
        if flag not in ['-t', '-r', '-I', '-n', '-g', '-en', '-eg', '-ej', '-es']:
            raise ValueError(f'Command from demography not contemplated in the script: {flag}')
        if flag == '-t':
            tbs_list.append(command.split(' ')[1])
        elif flag == '-r':
            tbs_list.append(command.split(' ')[1])
        elif flag in ['-n', '-g']:
            tbs_list.append(command.split(' ')[2])
        elif flag in ['-en', '-eg', '-es']:
            tbs_list.append(command.split(' ')[1])
            tbs_list.append(command.split(' ')[3])
        elif flag in ['-ej']:
            tbs_list.append(command.split(' ')[1])
    return tbs_list

def modify_graph_from_confint(graph, confint):
    """
    Modify the parameters of the demes graph drawing values from the confidence intervals
    """
    def draw_param_from_confint(param, confint):
        """
        Draw a parameter from the confidence intervals
        """
        return random.uniform(confint.loc[confint["parameter"] == param]["low_ci"].values[0],
                              confint.loc[confint["parameter"] == param]["high_ci"].values[0])
    
    params = {}
    for param in confint["parameter"]:
        params[param] = draw_param_from_confint(param, confint)
    
    ### change parameters in the demes graph:
    # first epoch in the pre-split population:
    graph.demes[0].epochs[0].end_time = params["t1"] + params["t2"] + params["t3"] + params["t4"]
    graph.demes[0].epochs[0].end_size = params["Nanc"]
    # second epoch in the pre-split population
    if graph.demes[0].epochs[1].size_function == "exponential":
        graph.demes[0].epochs[1].start_size = params["Nanc"]
        graph.demes[0].epochs[1].end_size = params["nu11"]
    else:
        graph.demes[0].epochs[1].start_size = params["nu11"]
        graph.demes[0].epochs[1].end_size = params["nu11"]
    graph.demes[0].epochs[1].end_time = params["t2"] + params["t3"] + params["t4"]
    graph.demes[1].start_time = graph.demes[0].epochs[1].end_time
    
    # first epoch post-split in pop1
    if graph.demes[0].epochs[2].size_function == "exponential":
        graph.demes[0].epochs[2].start_size = params["nu11_1"]
        graph.demes[0].epochs[2].end_size = params["nu21"]
    else:
        graph.demes[0].epochs[2].start_size = params["nu21"]
        graph.demes[0].epochs[2].end_size = params["nu21"]
    graph.demes[0].epochs[2].end_time = params["t3"] + params["t4"]
    # first epoch post-split in pop2
    if graph.demes[1].epochs[0].size_function == "exponential":
        graph.demes[1].epochs[0].start_size = params["nu11_2"]
        graph.demes[1].epochs[0].end_size = params["nu22"]
    else:
        graph.demes[1].epochs[0].start_size = params["nu22"]
        graph.demes[1].epochs[0].end_size = params["nu22"]
    graph.demes[1].epochs[0].end_time = params["t3"] + params["t4"]
    # second epoch post-split in pop1
    if graph.demes[0].epochs[3].size_function == "exponential":
        graph.demes[0].epochs[3].start_size = params["nu21"]
        graph.demes[0].epochs[3].end_size = params["nu31"]
    else:
        graph.demes[0].epochs[3].start_size = params["nu31"]
        graph.demes[0].epochs[3].end_size = params["nu31"]
    graph.demes[0].epochs[3].end_time = params["t4"]
    # second epoch post-split in pop2
    if graph.demes[1].epochs[1].size_function == "exponential":
        graph.demes[1].epochs[1].start_size = params["nu22"]
        graph.demes[1].epochs[1].end_size = params["nu32"]
    else:
        graph.demes[1].epochs[1].start_size = params["nu32"]
        graph.demes[1].epochs[1].end_size = params["nu32"]
    graph.demes[1].epochs[1].end_time = params["t4"]
    # third epoch post-split in pop1
    if graph.demes[0].epochs[4].size_function == "exponential":
        graph.demes[0].epochs[4].start_size = params["nu31"]
        graph.demes[0].epochs[4].end_size = params["nu41"]
    else:
        graph.demes[0].epochs[4].start_size = params["nu41"]
        graph.demes[0].epochs[4].end_size = params["nu41"]
    graph.demes[0].epochs[4].end_time = 0
    # third epoch post-split in pop2
    if graph.demes[1].epochs[2].size_function == "exponential":
        graph.demes[1].epochs[2].start_size = params["nu32"]
        graph.demes[1].epochs[2].end_size = params["nu42"]
    else:
        graph.demes[1].epochs[2].start_size = params["nu42"]
        graph.demes[1].epochs[2].end_size = params["nu42"]
    graph.demes[1].epochs[2].end_time = 0

    return graph

def get_sizes(pop):
    """
    Get the amount of samples to simulate based on the population name
    """
    if pop == 'lpa':
        return 44
    elif pop == 'wel':
        return 40
    elif pop == 'eel':
        return 38
    elif pop == 'sel':
        return 24
    else:
        raise ValueError("Population name not contemplated in the get_sizes script")

def main(demes_yaml, confint, path_to_msmodified, migration, nreps, L, mu, rec, odir, mtime):
    """
    Main workflow:
        - Load demes graph from yaml file
        - Add a pulse migration
        - Get ms command with a dummy theta (just for the ms string with tbs instead of parameters)
        - Then for each replicate:
            - Modify the demes graph with parameters drawn from the confidence intervals
            - Get the tbs values for the ms command
    """
    # Load the demes graph from a yaml file
    graph = get_graph_from_yaml(demes_yaml)
    # Change the demes graph based on the migration direction
    graph = remove_ancestral_populations(graph)
    # Add appropriate migration pulse to the demes graph
    # Load the confidence intervals from the csv file
    confint = pd.read_csv(confint)
    # Get the populations names from the demes graph
    pop1, pop2 = get_populations(graph)
    # Generate a dummy ms command (theta is not important) to get the ms command with tbs instead of parameters 
    mscommand = get_ms_command(graph = graph, N0 = 1000, L = L, samples=[get_sizes(pop1), get_sizes(pop2)], mu = mu, rec = rec, migration = migration, mtime = mtime)
    ms_string = get_ms_string(mscommand, path_to_msmodified, get_sizes(pop1), get_sizes(pop2), nreps, L)
    # move to odir
    os.chdir(odir)
    # write the tbs file
    with open('mig.tbs', 'w') as f:
        for _ in range(nreps):
            graph = modify_graph_from_confint(graph, confint)
            mscommand = get_ms_command(graph = graph, N0 = graph[pop1].epochs[0].end_size, migration = migration,
                                       L = L, samples = [get_sizes(pop1), get_sizes(pop2)], mu = mu, rec = rec, mtime = mtime)
            f.write(f"{' '.join(get_tbs_list(mscommand))}\n")
    # write the ms string
    os.system(f'echo "{ms_string}" > ms_string.sh\n')
    os.system(ms_string)
    # gzip useful output (mig.msOut and *.anc)
    os.system(f'gzip mig.msOut')
    os.system(f'gzip *.anc')

if __name__ == '__main__':
    args = parse_args()
    main(args.demes_yaml, args.confint, args.path_to_msmodified, args.migration, args.nreps, args.L, args.mu, args.rec, args.odir, args.mtime)
